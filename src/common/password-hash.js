import { pbkdf2, randomBytes } from 'crypto';
import Promise from 'bluebird';
import { logger } from './logger';

// Create Promise versions of some crypto functions
const randomBytesAsync = Promise.promisify(randomBytes);
const pbkdf2Async = Promise.promisify(pbkdf2);

// These constants can safely be changed without breaking existing hashes
const SALT_BYTES = 24;
const HASH_BYTES = 24;
const PBKDF2_ITERATIONS = 1000;

// These shouldn't be changed
const ITERATION_INDEX = 1;
const SALT_INDEX = 2;
const PBKDF2_INDEX = 3;

/**
 * Creates a salted PBKDF2-SHA1 hash of the password.
 * 
 * @param {string} password - The password to hash
 * @returns {Promise.<string>} The hashed password
 */
export function createHash(password) {
  // Generate a random salt
  const getSaltBytes = randomBytesAsync(SALT_BYTES);
  const getHashBytes = getSaltBytes.then(saltBytes => {
    return pbkdf2Async(password, saltBytes, PBKDF2_ITERATIONS, HASH_BYTES, 'sha1');
  });
  
  // Use salt and hash to generate a password hash string
  return Promise.join(getSaltBytes, getHashBytes, (saltBytes, hashBytes) => {
    return `sha1:${PBKDF2_ITERATIONS}:${saltBytes.toString('base64')}:${hashBytes.toString('base64')}`;
  });
};

/**
 * Validates a password against a given hash of the correct one. Use {@link #createHash} to generate
 * valid hashes for a password.
 * 
 * @param {string} password - The password to validate.
 * @param {string} goodHash - A good hash to compare the password to.
 * @returns {Promise.<boolean>} True if the password is valid otherwise false.
 */
export function validatePassword(password, goodHash) {
  // Split the hash into its parts and transform the strings into something useful
  const getSplitHash = Promise.try(() => {
    return goodHash.split(':').map((val, idx) => {
      switch (idx) {
        // Ignore the first part (should be 'sha1' string)
        case 0:
          return val;
        // Convert number of iterations to an int
        case ITERATION_INDEX:
          return parseInt(val);
        // Convert salt and hash to a Buffer
        case SALT_INDEX:
        case PBKDF2_INDEX:
          return new Buffer(val, 'base64');
        default:
          throw new Error(`Unexpected password hash part [${val}] at index [${idx}]`);
      }
    });
  });
  
  // Try hashing the password provided using the details from the split hash
  const getPasswordBytes = getSplitHash.then(hashParts => {
    const iterations = hashParts[ITERATION_INDEX];
    const saltBuffer = hashParts[SALT_INDEX];
    const hashLength = hashParts[PBKDF2_INDEX].length;
    return pbkdf2Async(password, saltBuffer, iterations, hashLength, 'sha1');
  });
  
  // Compare the generated bytes to the good bytes
  return Promise.join(getSplitHash, getPasswordBytes, (hashParts, passwordBytes) => {
    const goodBytes = hashParts[PBKDF2_INDEX];
    
    // For now, manually do a constant-time comparison to prevent timing attacks
    // (should be in node's crypto library after https://github.com/nodejs/node/pull/3073)
    let diff = goodBytes.length ^ passwordBytes.length;
    for (let i = 0; i < goodBytes.length && i < passwordBytes.length; i++) {
      diff |= goodBytes[i] ^ passwordBytes[i];
    }
    return diff === 0;
  });
};
